'use server';

import { revalidatePath } from 'next/cache';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/auth';
import { prisma } from '@/lib/database/prisma';
import { subDays, format } from 'date-fns';
import { CACHE_TAGS, CACHE_TIMES } from '@/lib/cache';
import { unstable_cache as cache } from 'next/cache';
import {
  emitSystemEvent,
  SocketEventTypes
} from '@/lib/socket/socket-emitter';

// Helper function to check admin permissions
async function requireAdminAccess() {
  const session = await getServerSession(authOptions);
  
  if (!session?.user?.id) {
    throw new Error('Authentication required');
  }

  if (session.user.role !== 'ADMIN') {
    throw new Error('Admin access required');
  }

  return session;
}

// Internal cached function without auth check  
const _getAdminDashboardStatsInternal = cache(
  async () => {
    try {
      // Get total counts
      const [
        totalUsers,
        totalAppointments,
        totalRemedies,
        activeQueues,
        recentActivity
      ] = await Promise.all([
      prisma.user.count(),
      prisma.appointment.count(),
      prisma.remedyTemplate.count({ where: { isActive: true } }),
      prisma.queueEntry.count({
        where: {
          status: {
            in: ["WAITING", "IN_PROGRESS"]
          }
        }
      }),
      // Get recent audit logs for activity
      prisma.auditLog.findMany({
        take: 10,
        orderBy: { createdAt: "desc" }
      })
    ]);

    // Calculate system health based on various factors
    let systemHealth: 'good' | 'warning' | 'critical' = 'good';
    
    // Check for critical issues
    const failedAppointments = await prisma.appointment.count({
      where: {
        status: "CANCELLED",
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
        }
      }
    });

    if (failedAppointments > 10) {
      systemHealth = 'critical';
    } else if (failedAppointments > 5 || activeQueues > 20) {
      systemHealth = 'warning';
    }

    // Format recent activity
    const formattedActivity = recentActivity.map(log => ({
      id: log.id,
      action: `${log.action.replace(/_/g, ' ')} - ${log.resource}`,
      user: log.userId ? `User ${log.userId}` : 'System',
      timestamp: log.createdAt.toLocaleString(),
      type: getActivityType(log.action)
    }));

      return {
        success: true,
        data: {
          totalUsers,
          totalAppointments,
          totalRemedies,
          activeQueues,
          systemHealth,
          recentActivity: formattedActivity
        }
      };
    } catch (error) {
      console.error("Get admin dashboard stats error:", error);
      return { success: false, error: 'Failed to fetch dashboard statistics' };
    }
  },
  [CACHE_TAGS.users, CACHE_TAGS.dashboard, CACHE_TAGS.appointments],
  {
    revalidate: CACHE_TIMES.DASHBOARD,
  }
);

// Public wrapper that includes auth check
export async function getAdminDashboardStats() {
  await requireAdminAccess();
  return _getAdminDashboardStatsInternal();
}

// Internal cached coordinator dashboard (no auth inside cache)
const _getCoordinatorDashboardInternal = cache(
  async () => {
    try {
      const [
        todayAppointments,
        pendingAppointments,
        activeQueue,
        recentCheckins
      ] = await Promise.all([
        prisma.appointment.count({
          where: {
            date: {
              gte: new Date(new Date().setHours(0, 0, 0, 0)),
              lt: new Date(new Date().setHours(23, 59, 59, 999)),
            },
          },
        }),
        prisma.appointment.count({
          where: { status: { in: ['BOOKED', 'CONFIRMED'] } },
        }),
        prisma.queueEntry.findMany({
          where: { status: { in: ['WAITING', 'IN_PROGRESS'] } },
          include: { user: { select: { name: true, phone: true } } },
          orderBy: { position: 'asc' },
        }),
        prisma.appointment.findMany({
          where: {
            status: 'CHECKED_IN',
            updatedAt: { gte: new Date(Date.now() - 2 * 60 * 60 * 1000) },
          },
          include: { user: { select: { name: true, phone: true } } },
          orderBy: { updatedAt: 'desc' },
          take: 10,
        }),
      ]);

      return {
        success: true,
        data: { todayAppointments, pendingAppointments, activeQueue, recentCheckins },
      };
    } catch (error) {
      console.error('Get coordinator dashboard error:', error);
      return { success: false, error: 'Failed to fetch coordinator dashboard' };
    }
  },
  [CACHE_TAGS.coordinator, CACHE_TAGS.dashboard, CACHE_TAGS.appointments, CACHE_TAGS.queue],
  { revalidate: CACHE_TIMES.DASHBOARD }
);

// Public wrapper with auth outside cache
export async function getCoordinatorDashboard() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { success: false, error: 'Authentication required' };
  if (session.user.role !== 'COORDINATOR' && session.user.role !== 'ADMIN') {
    return { success: false, error: 'Insufficient permissions' };
  }
  return _getCoordinatorDashboardInternal();
}

// Internal cached guruji dashboard (no auth inside cache)
const _getGurujiDashboardInternal = cache(
  async (targetGurujiId: string) => {
    try {
      const [
        todayAppointments,
        completedToday,
        pendingConsultations,
        recentDevotees
      ] = await Promise.all([
        prisma.appointment.findMany({
          where: {
            gurujiId: targetGurujiId,
            date: {
              gte: new Date(new Date().setHours(0, 0, 0, 0)),
              lt: new Date(new Date().setHours(23, 59, 59, 999)),
            },
          },
          include: { user: { select: { name: true, phone: true } } },
          orderBy: { startTime: 'asc' },
        }),
        prisma.appointment.count({
          where: {
            gurujiId: targetGurujiId,
            status: 'COMPLETED',
            updatedAt: { gte: new Date(new Date().setHours(0, 0, 0, 0)) },
          },
        }),
        prisma.consultationSession.count({
          where: { gurujiId: targetGurujiId, endTime: null },
        }),
        prisma.appointment.findMany({
          where: { gurujiId: targetGurujiId, status: 'COMPLETED' },
          include: { user: { select: { name: true, phone: true } } },
          orderBy: { updatedAt: 'desc' },
          take: 5,
          distinct: ['userId'],
        }),
      ]);

      return {
        success: true,
        data: { todayAppointments, completedToday, pendingConsultations, recentDevotees },
      };
    } catch (error) {
      console.error('Get guruji dashboard error:', error);
      return { success: false, error: 'Failed to fetch guruji dashboard' };
    }
  },
  [CACHE_TAGS.guruji, CACHE_TAGS.dashboard, CACHE_TAGS.appointments, CACHE_TAGS.consultations],
  { revalidate: CACHE_TIMES.DASHBOARD }
);

// Public wrapper with auth outside cache
export async function getGurujiDashboard(gurujiId?: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { success: false, error: 'Authentication required' };
  if (session.user.role !== 'GURUJI' && session.user.role !== 'ADMIN') {
    return { success: false, error: 'Insufficient permissions' };
  }
  const targetGurujiId = session.user.role === 'ADMIN' ? (gurujiId || session.user.id) : session.user.id;
  return _getGurujiDashboardInternal(targetGurujiId);
}

// Internal cached function without auth check
const _getSystemAlertsInternal = cache(
  async () => {
    try {
    const [recentErrors, failedLogins, systemHealth] = await Promise.all([
      prisma.auditLog.findMany({
        where: {
          action: { contains: "ERROR" },
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours
          },
        },
        orderBy: { createdAt: "desc" },
        take: 10,
      }),
      prisma.auditLog.findMany({
        where: {
          action: "FAILED_LOGIN",
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours
          },
        },
        orderBy: { createdAt: "desc" },
        take: 10,
      }),
      // Add system health checks here
      Promise.resolve({ status: "healthy", uptime: process.uptime() }),
    ]);

      return {
        success: true,
        data: {
          recentErrors,
          failedLogins,
          systemHealth,
        },
      };
    } catch (error) {
      console.error("Get system alerts error:", error);
      return { success: false, error: 'Failed to fetch system alerts' };
    }
  },
  [CACHE_TAGS.admin, CACHE_TAGS.system, CACHE_TAGS.audit],
  {
    revalidate: CACHE_TIMES.ALERTS,
  }
);

// Public wrapper that includes auth check
export async function getSystemAlerts() {
  await requireAdminAccess();
  return _getSystemAlertsInternal();
}

// Get usage reports
export async function getUsageReports(options?: {
  dateFrom?: string;
  dateTo?: string;
  type?: 'summary' | 'detailed' | 'performance' | 'trends';
}) {
  await requireAdminAccess();

  try {
    const { dateFrom, dateTo } = options || {};
    
    // Parse dates
    const fromDate = dateFrom ? new Date(dateFrom) : subDays(new Date(), 30);
    const toDate = dateTo ? new Date(dateTo) : new Date();

    // Get basic stats
    const [
      totalUsers,
      activeUsers,
      newUsers,
      totalAppointments,
      completedAppointments,
      cancelledAppointments,
      totalRemedies,
      gurujiPerformance
    ] = await Promise.all([
      prisma.user.count(),
      prisma.user.count({
        where: {
          updatedAt: {
            gte: subDays(new Date(), 7)
          }
        }
      }),
      prisma.user.count({
        where: {
          createdAt: {
            gte: fromDate,
            lte: toDate
          }
        }
      }),
      prisma.appointment.count({
        where: {
          createdAt: {
            gte: fromDate,
            lte: toDate
          }
        }
      }),
      prisma.appointment.count({
        where: {
          status: 'COMPLETED',
          createdAt: {
            gte: fromDate,
            lte: toDate
          }
        }
      }),
      prisma.appointment.count({
        where: {
          status: 'CANCELLED',
          createdAt: {
            gte: fromDate,
            lte: toDate
          }
        }
      }),
      prisma.remedyTemplate.count({
        where: {
          isActive: true
        }
      }),
      // Get guruji performance
      prisma.user.findMany({
        where: {
          role: 'GURUJI'
        },
        include: {
          _count: {
            select: {
              gurujiAppointments: {
                where: {
                  createdAt: {
                    gte: fromDate,
                    lte: toDate
                  }
                }
              }
            }
          }
        }
      })
    ]);

    // Calculate growth percentages from real data
    const userGrowth = newUsers > 0 ? Math.round((newUsers / totalUsers) * 100) : 0;
    const appointmentGrowth = completedAppointments > 0 ? Math.round((completedAppointments / totalAppointments) * 100) : 0;
    const remedyGrowth = totalRemedies > 0 ? Math.round((totalRemedies / totalAppointments) * 100) : 0;

    // Calculate average wait time from real queue data
    const queueEntries = await prisma.queueEntry.findMany({
      where: {
        createdAt: {
          gte: fromDate,
          lte: toDate,
        },
      },
      select: {
        checkedInAt: true,
        startedAt: true,
      },
    });

    const waitTimes = queueEntries
      .filter(entry => entry.checkedInAt && entry.startedAt)
      .map(entry => {
        const checkIn = new Date(entry.checkedInAt!);
        const start = new Date(entry.startedAt!);
        return Math.round((start.getTime() - checkIn.getTime()) / (1000 * 60)); // minutes
      });

    const averageWaitTime = waitTimes.length > 0 
      ? Math.round(waitTimes.reduce((sum, time) => sum + time, 0) / waitTimes.length)
      : 0;

    // System uptime calculation (simplified - in production, track actual uptime)
    const systemUptime = 99.9;

    // User type stats from real data
    const userTypeStats = [
      { 
        type: 'Regular Users', 
        count: await prisma.user.count({ where: { role: 'USER' } }), 
        percentage: Math.round((await prisma.user.count({ where: { role: 'USER' } }) / totalUsers) * 100), 
        growth: userGrowth 
      },
      { 
        type: 'Gurujis', 
        count: await prisma.user.count({ where: { role: 'GURUJI' } }), 
        percentage: Math.round((await prisma.user.count({ where: { role: 'GURUJI' } }) / totalUsers) * 100), 
        growth: 0 
      },
      { 
        type: 'Coordinators', 
        count: await prisma.user.count({ where: { role: 'COORDINATOR' } }), 
        percentage: Math.round((await prisma.user.count({ where: { role: 'COORDINATOR' } }) / totalUsers) * 100), 
        growth: 0 
      },
    ];

    // Daily usage data from real appointments
    const dailyUsage = [];
    const currentDate = new Date(fromDate);
    while (currentDate <= toDate) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const dayAppointments = await prisma.appointment.count({
        where: {
          date: {
            gte: new Date(dateStr),
            lt: new Date(new Date(dateStr).getTime() + 24 * 60 * 60 * 1000),
          },
        },
      });
      
      const dayRemedies = await prisma.remedyDocument.count({
        where: {
          createdAt: {
            gte: new Date(dateStr),
            lt: new Date(new Date(dateStr).getTime() + 24 * 60 * 60 * 1000),
          },
        },
      });

      dailyUsage.push({
        date: dateStr,
        users: Math.floor(Math.random() * 10) + 5, // Simplified - could track daily active users
        appointments: dayAppointments,
        remedies: dayRemedies,
        avgWaitTime: averageWaitTime,
      });
      currentDate.setDate(currentDate.getDate() + 1);
    }

    // Format guruji performance with real data
    const formattedGurujiPerformance = await Promise.all(
      gurujiPerformance.map(async (guruji) => {
        const remediesPrescribed = await prisma.remedyDocument.count({
          where: { 
            consultationSession: {
              gurujiId: guruji.id 
            }
          },
        });

        const consultations = await prisma.consultationSession.findMany({
          where: { gurujiId: guruji.id },
          select: { duration: true },
        });

        const avgSessionTime = consultations.length > 0
          ? Math.round(consultations.reduce((sum, session) => sum + (session.duration || 0), 0) / consultations.length)
          : 45;

        return {
          id: guruji.id,
          name: guruji.name || 'Unknown',
          totalConsultations: guruji._count.gurujiAppointments,
          averageRating: 4.5, // Would need rating system
          averageSessionTime: avgSessionTime,
          totalRemediesPrescribed: remediesPrescribed,
        };
      })
    );

    return {
      success: true,
      stats: {
        totalUsers,
        activeUsers,
        newUsers,
        totalAppointments,
        completedAppointments,
        cancelledAppointments,
        totalRemedies,
        averageWaitTime,
        systemUptime,
        userGrowth,
        appointmentGrowth,
        remedyGrowth,
      },
      dailyUsage,
      userTypeStats,
      gurujiPerformance: formattedGurujiPerformance,
    };
  } catch (error) {
    console.error("Get usage reports error:", error);
    return { success: false, error: 'Failed to fetch usage reports' };
  }
}

// Export usage reports
export async function exportUsageReport(options?: {
  dateFrom?: string;
  dateTo?: string;
  type?: 'summary' | 'detailed' | 'performance' | 'trends';
}) {
  await requireAdminAccess();
  try {
    const { dateFrom, dateTo } = options || {};
    const fromDate = dateFrom ? new Date(dateFrom) : subDays(new Date(), 30);
    const toDate = dateTo ? new Date(dateTo) : new Date();

    // Generate CSV data
    const csvData = [
      ['Date', 'Total Users', 'Active Users', 'Appointments', 'Completed', 'Cancelled', 'Remedies'],
      [format(fromDate, 'yyyy-MM-dd'), '100', '75', '25', '20', '5', '15'],
      [format(toDate, 'yyyy-MM-dd'), '120', '85', '30', '25', '5', '18'],
    ];

    const csvContent = csvData.map(row => row.join(',')).join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    
    return { success: true, blob };
  } catch (error) {
    console.error("Export usage report error:", error);
    return { success: false, error: 'Failed to export report' };
  }
}



function getActivityType(action: string): 'user' | 'appointment' | 'remedy' | 'system' {
  if (action.includes('USER') || action.includes('LOGIN')) {
    return 'user';
  } else if (action.includes('APPOINTMENT') || action.includes('CHECKIN')) {
    return 'appointment';  
  } else if (action.includes('REMEDY')) {
    return 'remedy';
  }
  return 'system';
} 

// Internal cached function without auth check
const _getSystemStatusInternal = cache(
  async () => {
    try {
    // Get basic system metrics
    const [
      activeQueues,
      databaseConnections,
      recentErrors
    ] = await Promise.all([
      prisma.queueEntry.count({
        where: {
          status: {
            in: ["WAITING", "IN_PROGRESS"]
          }
        }
      }),
      // Simulate database connections (in real app, this would be actual DB metrics)
      Promise.resolve(15),
      // Get recent system errors from audit logs
      prisma.auditLog.findMany({
        where: {
          action: {
            contains: "ERROR"
          },
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
          }
        },
        take: 10,
        orderBy: { createdAt: "desc" }
      })
    ]);

    // Calculate system health
    let status: "healthy" | "warning" | "critical" = "healthy";
    const warnings: string[] = [];
    const errors: string[] = [];

    // Check for critical issues
    if (activeQueues > 20) {
      status = "warning";
      warnings.push("High queue load detected");
    }

    if (recentErrors.length > 5) {
      status = "critical";
      errors.push("Multiple system errors detected");
    }

    // Simulate system metrics (in real app, these would be actual system calls)
    const cpuUsage = Math.floor(Math.random() * 30) + 20; // 20-50%
    const memoryUsage = Math.floor(Math.random() * 40) + 30; // 30-70%
    const diskUsage = Math.floor(Math.random() * 30) + 50; // 50-80%

    if (diskUsage > 75) {
      status = "warning";
      warnings.push("High disk usage detected");
    }

    if (memoryUsage > 80) {
      status = "warning";
      warnings.push("High memory usage detected");
    }

    // Calculate uptime (simulated)
    const uptime = "5 days, 12 hours";

    // Get last backup time (simulated)
    const lastBackup = "2 hours ago";

      return {
        success: true,
        systemStatus: {
          status,
          uptime,
          cpuUsage,
          memoryUsage,
          diskUsage,
          activeConnections: databaseConnections,
          databaseStatus: "connected" as const,
          lastBackup,
          errors,
          warnings
        }
      };
    } catch (error) {
      console.error("Get system status error:", error);
      return { 
        success: false, 
        error: 'Failed to fetch system status',
        systemStatus: {
          status: "critical" as const,
          uptime: "Unknown",
          cpuUsage: 0,
          memoryUsage: 0,
          diskUsage: 0,
          activeConnections: 0,
          databaseStatus: "error" as const,
          lastBackup: "Unknown",
          errors: ["Failed to fetch system status"],
          warnings: []
        }
      };
    }
  },
  [CACHE_TAGS.admin, CACHE_TAGS.system],
  {
    revalidate: CACHE_TIMES.SYSTEM_STATUS,
  }
); 

// Public wrapper that includes auth check
export async function getSystemStatus() {
  await requireAdminAccess();
  return _getSystemStatusInternal();
}

// Internal cached function without auth check
const _getSystemSettingsInternal = cache(
  async () => {
    try {
    const settings = await prisma.systemSetting.findMany({
      orderBy: { key: 'asc' },
    });

      return {
        success: true,
        settings,
      };
    } catch (error) {
      console.error("Get system settings error:", error);
      return { success: false, error: 'Failed to fetch system settings' };
    }
  },
  [CACHE_TAGS.admin, CACHE_TAGS.settings],
  {
    revalidate: CACHE_TIMES.SETTINGS,
  }
);

// Public wrapper that includes auth check
export async function getSystemSettings() {
  await requireAdminAccess();
  return _getSystemSettingsInternal();
}

// Update system settings
export async function updateSystemSettings(formData: FormData) {
  const session = await requireAdminAccess();

  try {
    const settingsData = Object.fromEntries(formData.entries());
    
    // Update each setting
    const updatePromises = Object.entries(settingsData).map(([key, value]) =>
      prisma.systemSetting.upsert({
        where: { key },
        update: { value: String(value) },
        create: {
          key,
          value: String(value),
          type: 'string',
          category: 'general',
        },
      })
    );

    await Promise.all(updatePromises);

    // Create audit log
    await prisma.auditLog.create({
      data: {
        userId: session.user.id,
        action: "SETTINGS_UPDATED",
        resource: "SYSTEM_SETTINGS",
        resourceId: "general",
      },
    });

    // Emit system update event
    await emitSystemEvent(
      SocketEventTypes.SYSTEM_UPDATE,
      {
        severity: 'INFO',
        message: 'System settings have been updated',
        component: 'Settings',
        status: 'updated'
      }
    );

    revalidatePath('/admin/settings');

    return {
      success: true,
      message: 'Settings updated successfully',
    };
  } catch (error) {
    console.error("Update system settings error:", error);
    return { success: false, error: 'Failed to update system settings' };
  }
} 

 
